<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title }}</title>

    <!-- Tailwind CSS (Local) -->
    <script src="js_lib/tailwindcss.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: { 50: '#eff6ff', 100: '#dbeafe', 200: '#bfdbfe', 300: '#93c5fd', 400: '#60a5fa', 500: '#3b82f6', 600: '#2563eb', 700: '#1d4ed8', 800: '#1e40af', 900: '#1e3a8a' }
                    }
                }
            }
        }
    </script>

    <!-- Alpine.js (Local) -->
    <script defer src="js_lib/alpine.min.js"></script>

    <!-- Plotly.js (Local) - Deferred for faster initial load -->
    <script defer src="js_lib/plotly.min.js"></script>

    <style>
        [x-cloak] {
            display: none !important;
        }

        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 4px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #a1a1a1;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .spinner {
            animation: spin 1s linear infinite;
        }

        .table-row-hover:hover {
            background-color: #f8fafc;
        }

        .gradient-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .plot-container {
            min-height: 450px;
            contain: layout style;
        }

        /* GPU-accelerated collapse animation */
        .section-content {
            transition: opacity 0.2s ease-out, transform 0.2s ease-out;
            transform-origin: top center;
            overflow: hidden;
        }

        .section-content.collapsed {
            opacity: 0;
            transform: scaleY(0);
            height: 0;
            pointer-events: none;
        }

        .section-content.expanded {
            opacity: 1;
            transform: scaleY(1);
        }
    </style>
</head>

<body class="bg-gray-100 text-gray-800 font-sans antialiased" x-data="gsMapApp()" x-init="init()" x-cloak>

    <!-- Header -->
    <header class="gradient-header text-white shadow-lg sticky top-0 z-50">
        <div class="max-w-full mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex items-center justify-between h-14">
                <div class="flex items-center gap-3">
                    <div class="bg-white/20 backdrop-blur-sm px-3 py-1 rounded-lg">
                        <span class="text-xl font-bold">gsMap</span>
                    </div>
                    <div class="hidden sm:block">
                        <h1 class="font-semibold">{{ project_name }}</h1>
                        <p class="text-xs text-white/70">{{ generated_at }}</p>
                    </div>
                    <!-- Dataset Type Badge -->
                    <span x-show="reportMeta?.dataset_type" class="ml-2 px-3 py-1 rounded-full text-sm font-medium"
                        :class="{
                            'bg-purple-100 text-purple-800': reportMeta?.dataset_type === 'spatial3D',
                            'bg-blue-100 text-blue-800': reportMeta?.dataset_type === 'spatial2D',
                            'bg-green-100 text-green-800': reportMeta?.dataset_type === 'scRNA'
                          }" x-text="reportMeta?.dataset_type_label || reportMeta?.dataset_type">
                    </span>
                </div>
                <div class="flex items-center gap-4">
                    <!-- Loading Indicator in header -->
                    <span x-show="isLoading" class="inline-flex items-center text-sm text-white/80">
                        <svg class="spinner -ml-1 mr-2 h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none"
                            viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4">
                            </circle>
                            <path class="opacity-75" fill="currentColor"
                                d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path>
                        </svg>
                        Loading...
                    </span>
                    <div class="text-sm text-white/80">v{{ gsmap_version }}</div>
                </div>
            </div>
        </div>
    </header>

    <!-- Layout: Sidebar + Main Content -->
    <div class="flex min-h-[calc(100vh-3.5rem)]">

        <!-- ==================== SIDEBAR ==================== -->
        <aside x-show="dataLoaded"
            class="w-64 bg-white border-r border-gray-200 flex-shrink-0 sticky top-14 h-[calc(100vh-3.5rem)] overflow-y-auto">
            <div class="p-4 space-y-6">
                <!-- Sidebar Header -->
                <div class="pb-3 border-b border-gray-200">
                    <h2 class="text-sm font-semibold text-gray-500 uppercase tracking-wider">Controls</h2>
                </div>

                <!-- Trait Selector -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Trait</label>
                    <select :value="selectedTrait" @change="handleTraitSelect($event.target.value)"
                        class="block w-full rounded-lg border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500 text-sm p-2.5 border bg-white">
                        <template x-for="t in traits" :key="t">
                            <option :value="t" x-text="t"></option>
                        </template>
                    </select>
                </div>

                <!-- Sample Selector -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Sample</label>
                    <select x-model="selectedSample" @change="onSampleChange()"
                        class="block w-full rounded-lg border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500 text-sm p-2.5 border bg-white">
                        <template x-for="s in samples" :key="s">
                            <option :value="s" x-text="s"></option>
                        </template>
                    </select>
                </div>

                <!-- Annotation Category Selector -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Annotation</label>
                    <select x-model="selectedAnnotationCategory" @change="onAnnotationChange()"
                        class="block w-full rounded-lg border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500 text-sm p-2.5 border bg-white">
                        <template x-for="anno in annotations" :key="anno">
                            <option :value="anno" x-text="anno"></option>
                        </template>
                    </select>
                </div>

                <!-- Gene Selector (only top genes) -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">
                        Top Gene <span class="text-gray-400 font-normal">(<span
                                x-text="topGenesDropdown.length"></span>)</span>
                    </label>
                    <select x-model="selectedGene" @change="onGeneChange()"
                        class="block w-full rounded-lg border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500 text-sm p-2.5 border bg-white">
                        <template x-for="g in topGenesDropdown" :key="g.gene">
                            <option :value="g.gene" x-text="g.gene + ' (' + (g.PCC ? g.PCC.toFixed(3) : 'N/A') + ')'">
                            </option>
                        </template>
                    </select>
                </div>

                <!-- Summary Stats -->
                <div class="pt-4 border-t border-gray-200">
                    <h3 class="text-xs font-semibold text-gray-500 uppercase tracking-wider mb-3">Summary</h3>
                    <div class="space-y-2 text-sm">
                        <div class="flex justify-between">
                            <span class="text-gray-500">Traits</span>
                            <span class="font-medium text-gray-900" x-text="traits.length"></span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-500">Samples</span>
                            <span class="font-medium text-gray-900" x-text="samples.length"></span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-500">Annotations</span>
                            <span class="font-medium text-gray-900" x-text="annotations.length"></span>
                        </div>
                    </div>
                </div>

                <!-- Section Navigation -->
                <div class="pt-4 border-t border-gray-200">
                    <h3 class="text-xs font-semibold text-gray-500 uppercase tracking-wider mb-3">Contents</h3>
                    <nav class="space-y-1">
                        <template x-for="section in visibleSections" :key="section.id">
                            <button
                                x-show="(section.id !== 'sec-spatial3d' || has3dWidget) && (section.id !== 'sec-umap' || umapData)"
                                @click="sections[section.id.replace('sec-', '')] = true; $nextTick(() => document.getElementById(section.id)?.scrollIntoView({behavior: 'smooth'}))"
                                class="w-full text-left px-3 py-2 text-sm rounded-lg hover:bg-gray-100 text-gray-700"
                                x-text="`${section.number}. ${section.title}`">
                            </button>
                        </template>
                    </nav>
                </div>
            </div>
        </aside>

        <!-- ==================== MAIN CONTENT ==================== -->
        <main class="flex-1 p-6 space-y-6 overflow-y-auto">

            <!-- Debug info (hidden by default, shown if no data) -->
            <div x-show="!dataLoaded" class="bg-yellow-50 border border-yellow-200 rounded-lg p-4">
                <p class="text-yellow-800 font-medium">Loading data...</p>
                <p class="text-yellow-600 text-sm mt-1">If this message persists, please check that js_data/ folder
                    exists
                    with the required .js files.</p>
            </div>

            <!-- ==================== SECTION 1: 3D SPATIAL VISUALIZATION ==================== -->
            <div id="sec-spatial3d" x-show="dataLoaded && currentSections.show3d && has3dWidget"
                class="bg-white rounded-xl shadow-sm border border-gray-200 overflow-hidden">
                <div class="p-4 border-b border-gray-100 flex justify-between items-center cursor-pointer"
                    @click="sections.spatial3d = !sections.spatial3d">
                    <div>
                        <h2 class="text-lg font-semibold text-gray-800" x-text="getSectionTitle('sec-spatial3d')"></h2>
                        <p class="text-sm text-gray-500">Interactive 3D view of spatial data with -log10(p) values and annotations side by side.</p>
                    </div>
                    <svg class="w-5 h-5 text-gray-500 transition-transform"
                        :class="sections.spatial3d ? 'rotate-180' : ''" fill="none" stroke="currentColor"
                        viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                    </svg>
                </div>
                <div class="section-content" :class="sections.spatial3d ? 'expanded' : 'collapsed'">
                    <!-- 3D Controls -->
                    <div class="p-4 bg-gray-50 border-b border-gray-200 flex flex-wrap items-center gap-6">
                        <div class="flex items-center gap-2">
                            <label class="text-sm font-medium text-gray-700">Trait:</label>
                            <span class="text-sm text-gray-600 bg-white px-3 py-2 rounded-lg border border-gray-300"
                                x-text="selectedTrait"></span>
                        </div>
                        <div class="flex items-center gap-2">
                            <label class="text-sm font-medium text-gray-700">Annotation:</label>
                            <span class="text-sm text-gray-600 bg-white px-3 py-2 rounded-lg border border-gray-300"
                                x-text="selectedAnnotationCategory"></span>
                        </div>
                    </div>

                    <!-- Side-by-side 3D views -->
                    <div class="p-2">
                        <div class="flex flex-wrap gap-4">
                            <!-- Left: Trait -log10(p) -->
                            <div class="flex-1 min-w-[500px] relative">
                                <h3 class="text-center font-medium text-gray-700 mb-2">
                                    -log10(p) - <span x-text="selectedTrait"></span>
                                </h3>
                                <!-- Loading Overlay for Trait -->
                                <div x-show="spatial3dTraitLoading"
                                    class="absolute inset-0 top-8 bg-white/60 backdrop-blur-[1px] z-10 flex items-center justify-center rounded-lg">
                                    <div class="flex flex-col items-center gap-3">
                                        <svg class="spinner h-10 w-10 text-primary-600" xmlns="http://www.w3.org/2000/svg"
                                            fill="none" viewBox="0 0 24 24">
                                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor"
                                                stroke-width="4"></circle>
                                            <path class="opacity-75" fill="currentColor"
                                                d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path>
                                        </svg>
                                        <span class="text-sm font-medium text-gray-600">Loading 3D Scene...</span>
                                    </div>
                                </div>
                                <template x-if="spatial3dTraitPath">
                                    <iframe :src="spatial3dTraitPath" @load="spatial3dTraitLoading = false"
                                        class="w-full border-0 rounded-lg" style="height: 800px; min-height: 600px;"
                                        loading="lazy" title="3D Spatial Visualization - Trait">
                                    </iframe>
                                </template>
                                <div x-show="!spatial3dTraitPath" class="p-8 text-center text-gray-500" style="height: 800px;">
                                    No 3D visualization available for this trait.
                                </div>
                            </div>
                            <!-- Right: Annotation -->
                            <div class="flex-1 min-w-[500px] relative">
                                <h3 class="text-center font-medium text-gray-700 mb-2">
                                    Annotation - <span x-text="selectedAnnotationCategory"></span>
                                </h3>
                                <!-- Loading Overlay for Annotation -->
                                <div x-show="spatial3dAnnotationLoading"
                                    class="absolute inset-0 top-8 bg-white/60 backdrop-blur-[1px] z-10 flex items-center justify-center rounded-lg">
                                    <div class="flex flex-col items-center gap-3">
                                        <svg class="spinner h-10 w-10 text-primary-600" xmlns="http://www.w3.org/2000/svg"
                                            fill="none" viewBox="0 0 24 24">
                                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor"
                                                stroke-width="4"></circle>
                                            <path class="opacity-75" fill="currentColor"
                                                d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path>
                                        </svg>
                                        <span class="text-sm font-medium text-gray-600">Loading 3D Scene...</span>
                                    </div>
                                </div>
                                <template x-if="spatial3dAnnotationPath">
                                    <iframe :src="spatial3dAnnotationPath" @load="spatial3dAnnotationLoading = false"
                                        class="w-full border-0 rounded-lg" style="height: 800px; min-height: 600px;"
                                        loading="lazy" title="3D Spatial Visualization - Annotation">
                                    </iframe>
                                </template>
                                <div x-show="!spatial3dAnnotationPath" class="p-8 text-center text-gray-500" style="height: 800px;">
                                    No 3D visualization available for this annotation.
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ==================== SECTION 2: gsMap 2D Distribution ==================== -->
            <div id="sec-gsmap" x-show="dataLoaded && currentSections.show2dDistribution"
                class="bg-white rounded-xl shadow-sm border border-gray-200 overflow-hidden">
                <div class="p-4 border-b border-gray-100 flex justify-between items-center cursor-pointer"
                    @click="sections.gsmap = !sections.gsmap">
                    <div>
                        <h2 class="text-lg font-semibold text-gray-800">
                            <span x-text="getSectionTitle('sec-gsmap')"></span> -
                            <span x-text="selectedSample"></span>
                        </h2>
                        <p class="text-sm text-gray-500">Spatial distribution of -log10(p) values and annotations side by side.</p>
                    </div>
                    <svg class="w-5 h-5 text-gray-500 transition-transform" :class="sections.gsmap ? 'rotate-180' : ''"
                        fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                    </svg>
                </div>
                <div class="section-content" :class="sections.gsmap ? 'expanded' : 'collapsed'">
                    <!-- Spatial 2D Controls -->
                    <div class="p-4 bg-gray-50 border-b border-gray-200 flex flex-wrap items-center gap-6">
                        <div class="flex items-center gap-2">
                            <label class="text-sm font-medium text-gray-700">Trait:</label>
                            <span class="text-sm text-gray-600 bg-white px-3 py-2 rounded-lg border border-gray-300"
                                x-text="selectedTrait"></span>
                        </div>
                        <div class="flex items-center gap-2">
                            <label class="text-sm font-medium text-gray-700">Annotation:</label>
                            <span class="text-sm text-gray-600 bg-white px-3 py-2 rounded-lg border border-gray-300"
                                x-text="selectedAnnotationCategory"></span>
                        </div>
                    </div>

                    <!-- Plotly Container with Loading Indicator -->
                    <div class="p-4">
                        <!-- Loading indicator -->
                        <div x-show="loadingSampleData" class="flex items-center justify-center py-12">
                            <svg class="animate-spin h-8 w-8 text-primary-600 mr-3" xmlns="http://www.w3.org/2000/svg"
                                fill="none" viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor"
                                    stroke-width="4"></circle>
                                <path class="opacity-75" fill="currentColor"
                                    d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                                </path>
                            </svg>
                            <span class="text-gray-500 text-lg">Loading sample data...</span>
                        </div>
                        <!-- Side-by-side plot containers -->
                        <div x-show="!loadingSampleData" class="flex flex-wrap gap-4">
                            <!-- Left: Trait -log10(p) -->
                            <div class="flex-1 min-w-[400px]">
                                <h3 class="text-center font-medium text-gray-700 mb-2">
                                    -log10(p) - <span x-text="selectedTrait"></span>
                                </h3>
                                <div id="spatial2dPlotTrait" class="w-full" style="height: 500px;"></div>
                            </div>
                            <!-- Right: Annotation -->
                            <div class="flex-1 min-w-[400px]">
                                <h3 class="text-center font-medium text-gray-700 mb-2">
                                    Annotation - <span x-text="selectedAnnotationCategory"></span>
                                </h3>
                                <div id="spatial2dPlotAnnotation" class="w-full" style="height: 500px;"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ==================== SECTION 3: GSS Distribution ==================== -->
            <div id="sec-genes" x-show="dataLoaded && currentSections.showGSS"
                class="bg-white rounded-xl shadow-sm border border-gray-200 overflow-hidden">
                <div class="p-4 border-b border-gray-100 flex justify-between items-center cursor-pointer"
                    @click="sections.genes = !sections.genes">
                    <div>
                        <h2 class="text-lg font-semibold text-gray-800">
                            <span x-text="getSectionTitle('sec-genes')"></span> -
                            <span x-text="selectedGene"></span> -
                            <span x-text="selectedSample"></span>
                        </h2>
                        <p class="text-sm text-gray-500">Gene expression and GSS distribution for selected sample.</p>
                    </div>
                    <svg class="w-5 h-5 text-gray-500 transition-transform" :class="sections.genes ? 'rotate-180' : ''"
                        fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                    </svg>
                </div>
                <div class="section-content" :class="sections.genes ? 'expanded' : 'collapsed'">
                    <!-- Gene Plot Info Bar -->
                    <div class="p-4 bg-gray-50 border-b border-gray-200 flex flex-wrap items-center gap-6">
                        <div class="flex items-center gap-2">
                            <label class="text-sm font-medium text-gray-700">Gene:</label>
                            <span class="text-sm text-gray-600 bg-white px-3 py-2 rounded-lg border border-gray-300"
                                x-text="selectedGene"></span>
                        </div>
                        <div class="flex items-center gap-2">
                            <label class="text-sm font-medium text-gray-700">Sample:</label>
                            <span class="text-sm text-gray-600 bg-white px-3 py-2 rounded-lg border border-gray-300"
                                x-text="selectedSample"></span>
                        </div>
                    </div>

                    <!-- Gene Plots (Side by Side: Expression and GSS) -->
                    <div class="p-4">
                        <!-- Loading indicator for gene plots -->
                        <div x-show="loadingGeneData" class="flex items-center justify-center py-12">
                            <svg class="animate-spin h-8 w-8 text-primary-600 mr-3" xmlns="http://www.w3.org/2000/svg"
                                fill="none" viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor"
                                    stroke-width="4"></circle>
                                <path class="opacity-75" fill="currentColor"
                                    d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                                </path>
                            </svg>
                            <span class="text-gray-500 text-lg">Loading gene data...</span>
                        </div>
                        <!-- Side-by-side static image containers - only render when ready -->
                        <template x-if="!loadingGeneData && selectedGene && selectedTrait && selectedSample">
                            <div class="flex flex-wrap gap-4 justify-center">
                                <div class="flex-1 min-w-[400px] max-w-[600px]">
                                    <h3 class="text-center font-medium text-gray-700 mb-2">Expression</h3>
                                    <img :src="'gene_diagnostic_plots/gene_' + selectedTrait + '_' + selectedGene + '_' + selectedSample.replace(/[^a-zA-Z0-9]/g, '_') + '_exp.png'"
                                        :alt="selectedGene + ' Expression'"
                                        class="w-full h-auto max-h-[500px] object-contain mx-auto"
                                        @error="$el.style.display='none'; $el.nextElementSibling.style.display='block';"
                                        @load="$el.style.display=''; $el.nextElementSibling.style.display='none';">
                                    <p class="text-center text-gray-400 py-8 text-sm" style="display: none;">
                                        Expression plot not available for this selection.</p>
                                </div>
                                <div class="flex-1 min-w-[400px] max-w-[600px]">
                                    <h3 class="text-center font-medium text-gray-700 mb-2">GSS</h3>
                                    <img :src="'gene_diagnostic_plots/gene_' + selectedTrait + '_' + selectedGene + '_' + selectedSample.replace(/[^a-zA-Z0-9]/g, '_') + '_gss.png'"
                                        :alt="selectedGene + ' GSS'"
                                        class="w-full h-auto max-h-[500px] object-contain mx-auto"
                                        @error="$el.style.display='none'; $el.nextElementSibling.style.display='block';"
                                        @load="$el.style.display=''; $el.nextElementSibling.style.display='none';">
                                    <p class="text-center text-gray-400 py-8 text-sm" style="display: none;">
                                        GSS plot not available for this selection.</p>
                                </div>
                            </div>
                        </template>
                    </div>

                    <!-- Gene Diagnostic Table -->
                    <div class="border-t border-gray-200">
                        <div class="p-4 bg-gray-50 flex justify-between items-center">
                            <h3 class="font-medium text-gray-700">Gene Diagnostic Table</h3>
                            <input type="text" x-model.debounce.300ms="geneSearchQuery" placeholder="Search genes..."
                                class="rounded-lg border-gray-300 shadow-sm text-sm p-2 border w-48">
                        </div>
                        <div class="overflow-x-auto overflow-y-auto custom-scrollbar max-h-[400px]"
                            @scroll="geneTableScroll = $event.target.scrollTop">
                            <div :style="{ minHeight: virtualGeneTable.totalHeight + 'px', position: 'relative' }">
                                <table class="min-w-full divide-y divide-gray-200"
                                    :style="{ position: 'absolute', top: virtualGeneTable.offsetY + 'px', left: 0, right: 0 }">
                                    <thead class="bg-gray-50">
                                        <tr>
                                            <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase cursor-pointer hover:bg-gray-100"
                                                @click="sortGenesBy('gene')">Gene</th>
                                            <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase cursor-pointer hover:bg-gray-100"
                                                @click="sortGenesBy('PCC')">PCC</th>
                                            <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase cursor-pointer hover:bg-gray-100"
                                                @click="sortGenesBy('Annotation')">Annotation</th>
                                            <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase cursor-pointer hover:bg-gray-100"
                                                @click="sortGenesBy('Median_GSS')">Median GSS</th>
                                        </tr>
                                    </thead>
                                    <tbody class="bg-white divide-y divide-gray-200">
                                        <template x-for="row in virtualGeneTable.items" :key="row.gene">
                                            <tr class="transition-colors duration-150"
                                                :style="{ height: geneTableRowHeight + 'px' }" :class="{
                                                'bg-primary-50': selectedGene === row.gene,
                                                'cursor-pointer hover:bg-gray-50': row.isTop,
                                                'cursor-not-allowed opacity-60 bg-gray-50': !row.isTop
                                            }" @click="if(row.isTop) { selectedGene = row.gene; onGeneChange(); }">
                                                <td class="px-4 py-2 text-sm text-gray-900"
                                                    :class="{'font-bold': row.isTop, 'font-medium': !row.isTop}"
                                                    x-text="row.gene"></td>
                                                <td class="px-4 py-2 text-sm text-gray-600 font-mono"
                                                    :class="{'font-bold': row.isTop}"
                                                    x-text="row.PCC ? row.PCC.toFixed(4) : 'N/A'"></td>
                                                <td class="px-4 py-2 text-sm"><span
                                                        class="px-2 py-0.5 text-xs rounded-full bg-gray-100"
                                                        x-text="row.Annotation || 'N/A'"></span></td>
                                                <td class="px-4 py-2 text-sm text-gray-600 font-mono"
                                                    x-text="row.Median_GSS ? row.Median_GSS.toFixed(4) : 'N/A'"></td>
                                            </tr>
                                        </template>
                                    </tbody>
                                </table>
                            </div>
                            <div x-show="virtualGeneTable.totalCount > 0"
                                class="sticky bottom-0 bg-gray-100 text-xs text-gray-500 p-2 text-center border-t">
                                Showing <span x-text="virtualGeneTable.items.length"></span> of <span
                                    x-text="virtualGeneTable.totalCount"></span> genes
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ==================== SECTION 4: Annotations 2D Distribution (Hidden - merged into sec-gsmap) ==================== -->
            <div id="sec-annotation" x-show="false"
                class="bg-white rounded-xl shadow-sm border border-gray-200 overflow-hidden">
                <div class="p-4 border-b border-gray-100 flex justify-between items-center cursor-pointer"
                    @click="sections.annotation = !sections.annotation">
                    <div>
                        <h2 class="text-lg font-semibold text-gray-800"><span
                                x-text="getSectionTitle('sec-annotation')"></span> - <span
                                x-text="selectedAnnotationCategory"></span></h2>
                        <p class="text-sm text-gray-500">Spatial distribution of annotations across samples.</p>
                    </div>
                    <svg class="w-5 h-5 text-gray-500 transition-transform"
                        :class="sections.annotation ? 'rotate-180' : ''" fill="none" stroke="currentColor"
                        viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                    </svg>
                </div>
                <div class="section-content p-4" :class="sections.annotation ? 'expanded' : 'collapsed'">
                    <img x-show="selectedAnnotationCategory"
                        :src="'annotation_plots/anno_' + selectedAnnotationCategory + '.png'"
                        :alt="selectedAnnotationCategory" class="w-full h-auto max-h-[700px] object-contain mx-auto"
                        loading="lazy" onerror="this.style.display='none';">
                    <p x-show="!selectedAnnotationCategory" class="text-center text-gray-500 py-8">Select an annotation
                        category to view the plot.</p>
                </div>
            </div>

            <!-- ==================== SECTION 5: UMAP EMBEDDINGS ==================== -->
            <div id="sec-umap" x-show="dataLoaded && currentSections.showUMAP && umapData"
                class="bg-white rounded-xl shadow-sm border border-gray-200 overflow-hidden">
                <div class="p-4 border-b border-gray-100 flex justify-between items-center cursor-pointer"
                    @click="sections.umap = !sections.umap">
                    <div>
                        <h2 class="text-lg font-semibold text-gray-800" x-text="getSectionTitle('sec-umap')"></h2>
                        <p class="text-sm text-gray-500">UMAP visualization of cell and niche embeddings with -log10(p) and annotations.</p>
                    </div>
                    <svg class="w-5 h-5 text-gray-500 transition-transform" :class="sections.umap ? 'rotate-180' : ''"
                        fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                    </svg>
                </div>
                <div class="section-content" :class="sections.umap ? 'expanded' : 'collapsed'">
                    <!-- UMAP Controls -->
                    <div class="p-4 bg-gray-50 border-b border-gray-200 flex flex-wrap items-center gap-6">
                        <div class="flex items-center gap-2">
                            <label class="text-sm font-medium text-gray-700">Trait:</label>
                            <span class="text-sm text-gray-600 bg-white px-3 py-2 rounded-lg border border-gray-300"
                                x-text="selectedTrait"></span>
                        </div>
                        <div class="flex items-center gap-2">
                            <label class="text-sm font-medium text-gray-700">Annotation:</label>
                            <span class="text-sm text-gray-600 bg-white px-3 py-2 rounded-lg border border-gray-300"
                                x-text="selectedAnnotationCategory"></span>
                        </div>
                        <div class="text-sm text-gray-500">
                            <span x-text="umapData ? umapData.spot.length : 0"></span> spots
                        </div>
                    </div>

                    <!-- UMAP Plots Container -->
                    <div class="p-4">
                        <!-- Row 1: Cell Embedding -->
                        <div class="mb-6">
                            <h3 class="text-lg font-medium text-gray-800 mb-3 border-b border-gray-200 pb-2">Cell Embedding</h3>
                            <div class="flex flex-wrap gap-4">
                                <!-- Left: Trait -log10(p) -->
                                <div class="flex-1 min-w-[400px]">
                                    <h4 class="text-center font-medium text-gray-600 mb-2 text-sm">
                                        -log10(p) - <span x-text="selectedTrait"></span>
                                    </h4>
                                    <div id="umapCellPlotTrait" class="w-full" style="height: 400px;"></div>
                                </div>
                                <!-- Right: Annotation -->
                                <div class="flex-1 min-w-[400px]">
                                    <h4 class="text-center font-medium text-gray-600 mb-2 text-sm">
                                        Annotation - <span x-text="selectedAnnotationCategory"></span>
                                    </h4>
                                    <div id="umapCellPlotAnnotation" class="w-full" style="height: 400px;"></div>
                                </div>
                            </div>
                        </div>

                        <!-- Row 2: Niche Embedding (only if available) -->
                        <div x-show="umapHasNiche">
                            <h3 class="text-lg font-medium text-gray-800 mb-3 border-b border-gray-200 pb-2">Niche Embedding</h3>
                            <div class="flex flex-wrap gap-4">
                                <!-- Left: Trait -log10(p) -->
                                <div class="flex-1 min-w-[400px]">
                                    <h4 class="text-center font-medium text-gray-600 mb-2 text-sm">
                                        -log10(p) - <span x-text="selectedTrait"></span>
                                    </h4>
                                    <div id="umapNichePlotTrait" class="w-full" style="height: 400px;"></div>
                                </div>
                                <!-- Right: Annotation -->
                                <div class="flex-1 min-w-[400px]">
                                    <h4 class="text-center font-medium text-gray-600 mb-2 text-sm">
                                        Annotation - <span x-text="selectedAnnotationCategory"></span>
                                    </h4>
                                    <div id="umapNichePlotAnnotation" class="w-full" style="height: 400px;"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ==================== SECTION 6: MANHATTAN PLOT ==================== -->
            <div id="sec-manhattan" x-show="dataLoaded && currentSections.showManhattan"
                class="bg-white rounded-xl shadow-sm border border-gray-200 overflow-hidden">
                <div class="p-4 border-b border-gray-100 flex justify-between items-center cursor-pointer"
                    @click="sections.manhattan = !sections.manhattan">
                    <div>
                        <h2 class="text-lg font-semibold text-gray-800" x-text="getSectionTitle('sec-manhattan')"></h2>
                        <p class="text-sm text-gray-500">GWAS results. Red = top PCC genes. Green diamond = selected
                            gene.</p>
                    </div>
                    <svg class="w-5 h-5 text-gray-500 transition-transform"
                        :class="sections.manhattan ? 'rotate-180' : ''" fill="none" stroke="currentColor"
                        viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                    </svg>
                </div>
                <div class="section-content" :class="sections.manhattan ? 'expanded' : 'collapsed'">
                    <div id="manhattanPlot" class="plot-container w-full"></div>
                </div>
            </div>

            <!-- ==================== SECTION 7: ENRICHMENT ANALYSIS ==================== -->
            <div id="sec-cauchy" x-show="dataLoaded && currentSections.showEnrichment"
                class="bg-white rounded-xl shadow-sm border border-gray-200 overflow-hidden">
                <div class="p-4 border-b border-gray-100 flex justify-between items-center cursor-pointer"
                    @click="sections.cauchy = !sections.cauchy">
                    <div>
                        <h2 class="text-lg font-semibold text-gray-800" x-text="getSectionTitle('sec-cauchy')"></h2>
                        <p class="text-sm text-gray-500">Statistical significance of annotations.</p>
                    </div>
                    <svg class="w-5 h-5 text-gray-500 transition-transform" :class="sections.cauchy ? 'rotate-180' : ''"
                        fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                    </svg>
                </div>
                <div class="section-content" :class="sections.cauchy ? 'expanded' : 'collapsed'">
                    <!-- Cauchy Controls -->
                    <div class="p-4 bg-gray-50 border-b border-gray-200 flex flex-wrap gap-4">
                        <div class="flex items-center gap-2">
                            <label class="text-sm font-medium text-gray-700">View:</label>
                            <select x-model="cauchyViewMode" @change="renderCauchyHeatmap()"
                                class="rounded-lg border-gray-300 shadow-sm text-sm p-2 border bg-white">
                                <option value="all">All Samples (Aggregated)</option>
                                <option value="sample">Per Sample</option>
                            </select>
                        </div>
                    </div>

                    <!-- Cauchy Table -->
                    <div class="overflow-x-auto custom-scrollbar max-h-[400px]">
                        <table class="min-w-full divide-y divide-gray-200">
                            <thead class="bg-gray-50 sticky top-0">
                                <tr>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase cursor-pointer hover:bg-gray-100"
                                        @click="sortCauchyBy('trait')">Trait</th>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase cursor-pointer hover:bg-gray-100"
                                        @click="sortCauchyBy('annotation')">Annotation</th>
                                    <th x-show="cauchyViewMode === 'sample'"
                                        class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase cursor-pointer hover:bg-gray-100"
                                        @click="sortCauchyBy('sample_name')">Sample</th>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase cursor-pointer hover:bg-gray-100"
                                        @click="sortCauchyBy('mlog10_p_cauchy')">-log10P (Cauchy)</th>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase cursor-pointer hover:bg-gray-100"
                                        @click="sortCauchyBy('mlog10_p_median')">-log10P (Median)</th>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase cursor-pointer hover:bg-gray-100"
                                        @click="sortCauchyBy('top_95_quantile')">95% Quantile (-log10P)</th>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">Total
                                        Spots</th>
                                </tr>
                            </thead>
                            <tbody class="bg-white divide-y divide-gray-200">
                                <template x-for="(row, idx) in filteredCauchyTable" :key="idx">
                                    <tr class="table-row-hover">
                                        <td class="px-4 py-2 text-sm font-medium text-gray-900" x-text="row.trait"></td>
                                        <td class="px-4 py-2 text-sm"><span
                                                class="px-2 py-0.5 text-xs rounded-full bg-primary-100 text-primary-700"
                                                x-text="row.annotation"></span></td>
                                        <td x-show="cauchyViewMode === 'sample'" class="px-4 py-2 text-sm text-gray-600"
                                            x-text="row.sample_name"></td>
                                        <td class="px-4 py-2 text-sm font-mono text-gray-600"
                                            x-text="row.mlog10_p_cauchy != null ? row.mlog10_p_cauchy.toFixed(2) : 'N/A'">
                                        </td>
                                        <td class="px-4 py-2 text-sm font-mono text-gray-600"
                                            x-text="row.mlog10_p_median != null ? row.mlog10_p_median.toFixed(2) : 'N/A'">
                                        </td>
                                        <td class="px-4 py-2 text-sm font-mono text-gray-600"
                                            x-text="row.top_95_quantile != null ? row.top_95_quantile.toFixed(2) : 'N/A'">
                                        </td>
                                        <td class="px-4 py-2 text-sm text-gray-600" x-text="row.total_spots"></td>
                                    </tr>
                                </template>
                            </tbody>
                        </table>
                    </div>

                    <!-- Cauchy Heatmap -->
                    <div class="border-t border-gray-200">
                        <div
                            class="p-4 bg-gray-50 border-b border-gray-200 flex flex-wrap justify-between items-center gap-4">
                            <div>
                                <h3 class="font-medium text-gray-700" x-text="'7.2 Cauchy Enrichment Heatmap (' + (
                                    cauchyHeatmapMetric === 'mlog10_p_cauchy' ? 'Cauchy P-Value' : 
                                    cauchyHeatmapMetric === 'mlog10_p_median' ? 'Median P-Value' : 'Q95'
                                ) + ')'"></h3>
                                <p class="text-xs text-gray-500 mt-1" x-text="
                                    cauchyHeatmapMetric === 'mlog10_p_cauchy' ? 'Aggregated significance across all spots.' :
                                    cauchyHeatmapMetric === 'mlog10_p_median' ? 'Median spot significance in the annotation.' :
                                    'The 95th percentile of significance (-log10p) across spots.'
                                "></p>
                            </div>
                            <div class="flex flex-wrap items-center gap-4">
                                <div class="flex items-center gap-2">
                                    <label class="text-sm font-medium text-gray-700">Metric:</label>
                                    <select x-model="cauchyHeatmapMetric" @change="renderCauchyHeatmap()"
                                        class="rounded-lg border-gray-300 shadow-sm text-sm p-2 border bg-white">
                                        <option value="mlog10_p_cauchy">Cauchy P-Value</option>
                                        <option value="mlog10_p_median">Median P-Value</option>
                                        <option value="top_95_quantile">Q95 (-log10P)</option>
                                    </select>
                                </div>
                                <div class="flex items-center gap-2">
                                    <label class="inline-flex items-center cursor-pointer">
                                        <input type="checkbox" x-model="cauchyHeatmapCluster"
                                            @change="renderCauchyHeatmap()"
                                            class="rounded border-gray-300 text-primary-600 focus:ring-primary-500 h-4 w-4">
                                        <span class="ml-2 text-sm text-gray-700">Cluster</span>
                                    </label>
                                </div>
                                <div class="flex items-center gap-2">
                                    <label class="inline-flex items-center cursor-pointer">
                                        <input type="checkbox" x-model="cauchyHeatmapNormalize"
                                            @change="renderCauchyHeatmap()"
                                            class="rounded border-gray-300 text-primary-600 focus:ring-primary-500 h-4 w-4">
                                        <span class="ml-2 text-sm text-gray-700">0-1 Normalize</span>
                                    </label>
                                </div>
                            </div>
                        </div>
                        <div id="cauchyHeatmap" class="plot-container w-full"></div>
                    </div>
                </div>
            </div>

            <!-- ==================== SECTION 8: REPORT INFORMATION ==================== -->
            <div id="sec-info" x-show="dataLoaded && currentSections.showInfo"
                class="bg-white rounded-xl shadow-sm border border-gray-200 overflow-hidden">
                <div class="p-4 border-b border-gray-100 flex justify-between items-center cursor-pointer"
                    @click="sections.info = !sections.info">
                    <div>
                        <h2 class="text-lg font-semibold text-gray-800" x-text="getSectionTitle('sec-info')"></h2>
                        <p class="text-sm text-gray-500">Configuration and summary statistics.</p>
                    </div>
                    <svg class="w-5 h-5 text-gray-500 transition-transform" :class="sections.info ? 'rotate-180' : ''"
                        fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                    </svg>
                </div>
                <div class="section-content" :class="sections.info ? 'expanded' : 'collapsed'">
                    <!-- Summary Cards -->
                    <div class="p-4 grid grid-cols-1 md:grid-cols-3 gap-4">
                        <div class="text-center p-4 bg-primary-50 rounded-lg">
                            <p class="text-2xl font-bold text-primary-600" x-text="traits.length"></p>
                            <p class="text-sm text-gray-600">Traits</p>
                        </div>
                        <div class="text-center p-4 bg-green-50 rounded-lg">
                            <p class="text-2xl font-bold text-green-600" x-text="samples.length"></p>
                            <p class="text-sm text-gray-600">Samples</p>
                        </div>
                        <div class="text-center p-4 bg-purple-50 rounded-lg">
                            <p class="text-2xl font-bold text-purple-600" x-text="annotations.length"></p>
                            <p class="text-sm text-gray-600">Annotation Categories</p>
                        </div>
                    </div>
                    <!-- Config JSON -->
                    <div class="border-t border-gray-200 p-4 bg-gray-50">
                        <h3 class="font-medium text-gray-700 mb-2">Configuration</h3>
                        <pre class="text-xs text-gray-600 whitespace-pre-wrap font-mono bg-white p-3 rounded border max-h-64 overflow-auto"
                            x-text="JSON.stringify(reportMeta, null, 2)"></pre>
                    </div>
                </div>
            </div>

        </main>
    </div><!-- End of flex layout -->

    <!-- Footer -->
    <footer class="bg-white border-t border-gray-200">
        <div class="max-w-full mx-auto px-4 py-3">
            <p class="text-center text-sm text-gray-500">gsMap Report | Version {{ gsmap_version }}</p>
        </div>
    </footer>

    <!-- Data Scripts - MUST load before Alpine initializes -->
    <script src="js_data/report_meta.js"></script>
    <script src="js_data/sample_index.js"></script>
    <script src="js_data/cauchy_results.js"></script>
    <!-- Gene trait correlation data is now loaded per-trait on demand from js_data/gss_stats/ -->
    <script src="js_data/umap_data.js"></script>

    <script>
        function gsMapApp() {
            return {
                // Data loaded flag
                dataLoaded: false,
                plotlyReady: false,

                // Global state
                selectedTrait: '',
                selectedAnnotationCategory: '',
                selectedGene: '',
                isLoading: false,

                // Data arrays (populated from window globals)
                traits: [],
                samples: [],
                annotations: [],
                topCorrGenes: 50,
                chromTickPositions: {},

                // Section collapse state
                sections: {
                    manhattan: true,
                    umap: true,
                    spatial3d: true,
                    gsmap: true,
                    annotation: true,
                    genes: true,
                    cauchy: true,
                    info: false
                },

                // Raw data
                reportMeta: {},
                cauchyData: [],
                topGenesPccCache: {},  // Per-trait cache: { traitName: [geneData] }
                topGenesPccLoadedTraits: {},  // Track loaded traits
                topGenesList: [],

                // UMAP state
                umapData: null,
                umapHasNiche: false,
                umapAnnotationColumns: [],
                selectedUmapAnnotation: '',
                umapCellPlotTraitInitialized: false,
                umapCellPlotAnnotationInitialized: false,
                umapNichePlotTraitInitialized: false,
                umapNichePlotAnnotationInitialized: false,

                // 3D visualization state
                is3d: false,
                has3dWidget: false,
                spatial3dTraitLoading: true,
                spatial3dAnnotationLoading: true,

                // Spatial 2D visualization state
                selectedSample: '',
                spatial2dPlotTraitInitialized: false,
                spatial2dPlotAnnotationInitialized: false,

                // Per-sample data loading (for efficient on-demand loading)
                sampleDataCache: {},        // { sampleName: data } - cache loaded samples
                loadingSampleData: false,   // Loading indicator
                currentSampleData: null,    // Currently loaded sample data
                loadingGeneData: false,     // Loading indicator for gene PCC data

                // Section visibility configuration by dataset type
                sectionConfig: {
                    'spatial3D': {
                        show3d: true,
                        show2dDistribution: true,
                        showGSS: true,
                        showAnnotations: true,
                        showUMAP: true,
                        showManhattan: true,
                        showEnrichment: true,
                        showInfo: true
                    },
                    'spatial2D': {
                        show3d: false,
                        show2dDistribution: true,
                        showGSS: true,
                        showAnnotations: true,
                        showUMAP: true,
                        showManhattan: true,
                        showEnrichment: true,
                        showInfo: true
                    },
                    'scRNA': {
                        show3d: false,
                        show2dDistribution: false,
                        showGSS: false,
                        showAnnotations: false,
                        showUMAP: true,
                        showManhattan: true,
                        showEnrichment: true,
                        showInfo: true
                    }
                },

                // Section definitions for dynamic numbering
                sectionDefs: [
                    { key: 'show3d', id: 'sec-spatial3d', title: 'gsMap 3D Exploration' },
                    { key: 'show2dDistribution', id: 'sec-gsmap', title: 'gsMap 2D Distribution' },
                    { key: 'showGSS', id: 'sec-genes', title: 'GSS Distribution' },
                    // Annotation section merged into sec-gsmap, removed from navigation
                    // { key: 'showAnnotations', id: 'sec-annotation', title: 'Annotations 2D Distribution' },
                    { key: 'showUMAP', id: 'sec-umap', title: 'Embedding UMAP' },
                    { key: 'showManhattan', id: 'sec-manhattan', title: 'Manhattan Plot' },
                    { key: 'showEnrichment', id: 'sec-cauchy', title: 'Enrichment Analysis' },
                    { key: 'showInfo', id: 'sec-info', title: 'Report Information' }
                ],

                // Computed: current section visibility based on dataset type
                get currentSections() {
                    const datasetType = this.reportMeta?.dataset_type || 'spatial3D';
                    return this.sectionConfig[datasetType] || this.sectionConfig['spatial3D'];
                },

                // Computed: visible sections with dynamic numbering
                get visibleSections() {
                    const config = this.currentSections;
                    const visible = [];
                    let num = 1;
                    for (const s of this.sectionDefs) {
                        if (config[s.key]) {
                            visible.push({ ...s, number: num++ });
                        }
                    }
                    return visible;
                },

                // Helper method to get section title with number
                getSectionTitle(sectionId) {
                    const section = this.visibleSections.find(s => s.id === sectionId);
                    return section ? `${section.number}. ${section.title}` : '';
                },

                // Helper to check if a section should be shown
                isSectionVisible(sectionKey) {
                    return this.currentSections[sectionKey] || false;
                },

                // Computed property for 3D trait path
                get spatial3dTraitPath() {
                    if (!this.has3dWidget) return '';
                    const name = this.selectedTrait;
                    if (!name) return '';
                    const safeName = name.replace(/[^a-zA-Z0-9]/g, '_');
                    return `spatial_3d/spatial_3d_trait_${safeName}.html`;
                },

                // Computed property for 3D annotation path
                get spatial3dAnnotationPath() {
                    if (!this.has3dWidget) return '';
                    const name = this.selectedAnnotationCategory;
                    if (!name) return '';
                    const safeName = name.replace(/[^a-zA-Z0-9]/g, '_');
                    return `spatial_3d/spatial_3d_anno_${safeName}.html`;
                },

                // Manhattan state
                manhattanLoadedTraits: {},
                manhattanData: null,
                manhattanPlotInitialized: false,
                manhattanTraceCache: null,
                chrColors: ['#1f77b4', '#aec7e8'],

                // Gene table state
                geneSearchQuery: '',
                geneSortKey: 'PCC',
                geneSortAsc: false,

                // Memoization caches
                _geneFilterCache: null,
                _geneFilterKey: '',
                _cauchyFilterCache: null,
                _cauchyFilterKey: '',

                // Virtual scrolling state
                geneTableScroll: 0,
                geneTableRowHeight: 40,
                geneTableVisibleCount: 12,

                // Cauchy state
                cauchyViewMode: 'all',
                cauchySortKey: 'mlog10_p_median',
                cauchySortAsc: false,
                cauchyHeatmapMetric: 'mlog10_p_cauchy',
                cauchyHeatmapCluster: true,
                cauchyHeatmapNormalize: false,

                // Memoized: filtered gene table
                get filteredGeneTable() {
                    const key = `${this.selectedTrait}|${this.geneSearchQuery}|${this.geneSortKey}|${this.geneSortAsc}`;
                    if (this._geneFilterKey === key && this._geneFilterCache) {
                        return this._geneFilterCache;
                    }

                    let data = this.topGenesList || [];
                    if (this.geneSearchQuery) {
                        const q = this.geneSearchQuery.toLowerCase();
                        data = data.filter(r => r.gene.toLowerCase().includes(q));
                    }
                    const sortKey = this.geneSortKey, asc = this.geneSortAsc;
                    const result = [...data].sort((a, b) => {
                        let va = a[sortKey], vb = b[sortKey];
                        if (va == null) return 1;
                        if (vb == null) return -1;
                        if (typeof va === 'string') { va = va.toLowerCase(); vb = (vb || '').toLowerCase(); }
                        if (va < vb) return asc ? -1 : 1;
                        if (va > vb) return asc ? 1 : -1;
                        return 0;
                    });

                    this._geneFilterKey = key;
                    this._geneFilterCache = result;
                    return result;
                },

                // Virtual scrolling for gene table
                get virtualGeneTable() {
                    const allData = this.filteredGeneTable;
                    const start = Math.floor(this.geneTableScroll / this.geneTableRowHeight);
                    const buffer = 5;
                    const startIdx = Math.max(0, start - buffer);
                    const endIdx = Math.min(allData.length, start + this.geneTableVisibleCount + buffer * 2);

                    return {
                        items: allData.slice(startIdx, endIdx),
                        totalHeight: allData.length * this.geneTableRowHeight,
                        offsetY: startIdx * this.geneTableRowHeight,
                        totalCount: allData.length
                    };
                },

                // Dropdown list: only top N genes (for sidebar selector)
                get topGenesDropdown() {
                    return (this.topGenesList || []).filter(g => g.isTop);
                },

                // Memoized: filtered cauchy table
                get filteredCauchyTable() {
                    const key = `${this.selectedTrait}|${this.selectedAnnotationCategory}|${this.cauchyViewMode}|${this.cauchySortKey}|${this.cauchySortAsc}`;
                    if (this._cauchyFilterKey === key && this._cauchyFilterCache) {
                        return this._cauchyFilterCache;
                    }

                    let data = this.cauchyData || [];
                    data = data.filter(r =>
                        (this.cauchyViewMode === 'all' ? r.type === 'aggregated' : r.type === 'sample') &&
                        r.trait === this.selectedTrait &&
                        r.annotation_name === this.selectedAnnotationCategory
                    );
                    const sortKey = this.cauchySortKey, asc = this.cauchySortAsc;
                    const result = [...data].sort((a, b) => {
                        let va = a[sortKey], vb = b[sortKey];
                        if (va == null) return 1;
                        if (vb == null) return -1;
                        if (typeof va === 'string') { va = (va || '').toLowerCase(); vb = (vb || '').toLowerCase(); }
                        if (va < vb) return asc ? -1 : 1;
                        if (va > vb) return asc ? 1 : -1;
                        return 0;
                    });

                    this._cauchyFilterKey = key;
                    this._cauchyFilterCache = result;
                    return result;
                },

                // Wait for Plotly to load (deferred)
                waitForPlotly() {
                    return new Promise(resolve => {
                        if (typeof Plotly !== 'undefined') {
                            this.plotlyReady = true;
                            return resolve();
                        }
                        const check = setInterval(() => {
                            if (typeof Plotly !== 'undefined') {
                                this.plotlyReady = true;
                                clearInterval(check);
                                resolve();
                            }
                        }, 50);
                    });
                },

                // Initialize
                async init() {
                    console.log("Initializing gsMap Report...");

                    // Load data from window globals
                    if (window.GSMAP_REPORT_META) {
                        this.reportMeta = window.GSMAP_REPORT_META;
                        this.traits = this.reportMeta.traits || [];
                        this.samples = this.reportMeta.samples || [];
                        this.annotations = this.reportMeta.annotations || [];
                        this.topCorrGenes = this.reportMeta.top_corr_genes || 50;
                        this.chromTickPositions = this.reportMeta.chrom_tick_positions || {};
                        console.log("Loaded report meta:", this.traits.length, "traits,", this.samples.length, "samples");
                    } else {
                        console.warn("GSMAP_REPORT_META not found!");
                    }

                    if (window.GSMAP_CAUCHY) {
                        this.cauchyData = window.GSMAP_CAUCHY;
                        console.log("Loaded", this.cauchyData.length, "Cauchy results");
                    }

                    // Gene trait correlation data is now loaded per-trait on demand
                    // (see loadGenePccData method)

                    // Load UMAP data
                    if (window.GSMAP_UMAP) {
                        this.umapData = window.GSMAP_UMAP;
                        this.umapHasNiche = this.umapData.has_niche || false;
                        this.umapAnnotationColumns = this.umapData.annotation_columns || [];
                        if (this.umapAnnotationColumns.length > 0) {
                            this.selectedUmapAnnotation = this.umapAnnotationColumns[0];
                        }
                        console.log("Loaded UMAP data:", this.umapData.spot.length, "points, has_niche:", this.umapHasNiche);
                    }

                    // Load 3D visualization state
                    this.is3d = this.reportMeta.is_3d || false;
                    this.has3dWidget = this.reportMeta.has_3d_widget || false;
                    if (this.has3dWidget) {
                        console.log("3D visualization widget available");
                    }

                    // Check if data loaded successfully
                    if (this.traits.length > 0) {
                        // Initialize selections
                        this.selectedTrait = this.traits[0];
                        if (this.annotations.length > 0) {
                            this.selectedAnnotationCategory = this.annotations[0];
                        }
                        if (this.samples.length > 0) {
                            this.selectedSample = this.samples[0];
                        }

                        // Update gene list (async - loads per-trait data)
                        // Must complete before dataLoaded=true to ensure selectedGene is set
                        await this.updateGeneList();

                        // Now safe to show the UI - all selections are initialized
                        this.dataLoaded = true;

                        // Wait for Plotly to load, then render plots
                        await this.waitForPlotly();
                        this.loadManhattanData();
                        this.renderCauchyHeatmap();
                        this.renderUmapPlots();

                        // Load first sample data then render spatial 2D plot
                        if (this.selectedSample) {
                            await this.loadSampleData(this.selectedSample);
                            this.renderSpatial2DPlot();
                            // Static gene plots load automatically via img src binding
                        }
                    } else {
                        console.error("No traits found - data may not have loaded correctly");
                    }
                },

                // Event handlers
                // Handle trait selection - set loading flag BEFORE changing trait to prevent bad image requests
                handleTraitSelect(newTrait) {
                    if (newTrait === this.selectedTrait) return;
                    this.loadingGeneData = true; // Set BEFORE trait changes
                    this.selectedGene = '';      // Clear BEFORE trait changes
                    this.topGenesList = [];      // Clear gene list to prevent stale data in table
                    this._geneFilterCache = null; // Invalidate cache BEFORE trait changes
                    this._geneFilterKey = '';
                    this.selectedTrait = newTrait;
                    this.onTraitChange();
                },

                async onTraitChange() {
                    // loadingGeneData and selectedGene are already set by handleTraitSelect()
                    this._geneFilterCache = null; // Invalidate cache
                    this._cauchyFilterCache = null;
                    this.manhattanTraceCache = null; // Invalidate Manhattan cache
                    await this.updateGeneList(); // This will set the new selectedGene
                    this.loadingGeneData = false; // Gene data ready
                    this.loadManhattanData();

                    // Update 3D visualization - trait view needs reload
                    this.spatial3dTraitLoading = true;

                    // Update UMAP plots (both trait and annotation views)
                    this.renderUmapPlots();

                    // Update spatial 2D plots (both trait and annotation views)
                    this.renderSpatial2DPlot();
                },

                onAnnotationChange() {
                    this._cauchyFilterCache = null;

                    // Update 3D visualization - annotation view needs reload
                    this.spatial3dAnnotationLoading = true;

                    // Update UMAP plots (both trait and annotation views)
                    this.renderUmapPlots();

                    // Update spatial 2D plots (both trait and annotation views)
                    this.renderSpatial2DPlot();

                    // Update Cauchy Heatmap
                    this.renderCauchyHeatmap();
                },

                onSampleChange() {
                    // Load sample data on-demand then render
                    this.loadSampleData(this.selectedSample).then(() => {
                        this.renderSpatial2DPlot();
                    }).catch(err => {
                        console.error('Failed to load sample data:', err);
                    });
                    // Static gene plots update automatically via img src binding
                },

                // Load sample data on-demand via dynamic script injection
                async loadSampleData(sampleName) {
                    // Return cached data if available
                    if (this.sampleDataCache[sampleName]) {
                        this.currentSampleData = this.sampleDataCache[sampleName];
                        return this.currentSampleData;
                    }

                    // Get sample info from index
                    const sampleInfo = window.GSMAP_SAMPLE_INDEX?.[sampleName];
                    if (!sampleInfo) {
                        console.warn(`Sample ${sampleName} not found in index`);
                        return null;
                    }

                    this.loadingSampleData = true;

                    return new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        script.src = `js_data/${sampleInfo.file}`;

                        script.onload = () => {
                            const data = window[sampleInfo.var_name];
                            if (data) {
                                this.sampleDataCache[sampleName] = data;
                                this.currentSampleData = data;
                                // Show downsampling info if applicable
                                const nSpots = data.spot?.length || 0;
                                const nSpotsOriginal = sampleInfo.n_spots_original || nSpots;
                                if (nSpotsOriginal > nSpots) {
                                    console.log(`Loaded sample ${sampleName}: ${nSpots.toLocaleString()} spots (downsampled from ${nSpotsOriginal.toLocaleString()})`);
                                } else {
                                    console.log(`Loaded sample ${sampleName}: ${nSpots.toLocaleString()} spots`);
                                }
                                resolve(data);
                            } else {
                                reject(new Error(`Data not found for ${sampleName}`));
                            }
                            this.loadingSampleData = false;
                        };

                        script.onerror = () => {
                            console.error(`Failed to load sample data: ${sampleName}`);
                            this.loadingSampleData = false;
                            reject(new Error(`Failed to load ${sampleName}`));
                        };

                        document.body.appendChild(script);
                    });
                },

                onGeneChange() {
                    if (this.manhattanData && this.plotlyReady) {
                        this.renderManhattanPlot();
                    }
                    // Static gene plots update automatically via img src binding
                },

                // Load gene PCC data for a specific trait on demand
                async loadGenePccData(trait) {
                    // Return cached data if available
                    if (this.topGenesPccCache[trait]) {
                        return this.topGenesPccCache[trait];
                    }

                    const safeTrait = trait.replace(/[^a-zA-Z0-9]/g, '_');
                    const varName = `GSMAP_GENE_TRAIT_CORRELATION_${safeTrait}`;

                    // Check if already loaded in window
                    if (this.topGenesPccLoadedTraits[trait] && window[varName]) {
                        this.topGenesPccCache[trait] = window[varName];
                        return this.topGenesPccCache[trait];
                    }

                    // Load script dynamically from gss_stats subfolder
                    return new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        script.src = `js_data/gss_stats/gene_trait_correlation_${trait}.js`;

                        script.onload = () => {
                            this.topGenesPccLoadedTraits[trait] = true;
                            if (window[varName]) {
                                this.topGenesPccCache[trait] = window[varName];
                                console.log(`Loaded gene PCC data for ${trait}:`, window[varName].length, 'genes');
                                resolve(this.topGenesPccCache[trait]);
                            } else {
                                console.warn(`Gene PCC variable ${varName} not found after loading script`);
                                resolve([]);
                            }
                        };

                        script.onerror = () => {
                            console.warn(`Failed to load gene PCC data for ${trait}`);
                            resolve([]);
                        };

                        document.body.appendChild(script);
                    });
                },

                // Update gene list when trait changes
                async updateGeneList() {
                    const trait = this.selectedTrait;
                    if (!trait) {
                        this.topGenesList = [];
                        return;
                    }

                    // Load trait-specific gene PCC data
                    const traitGeneData = await this.loadGenePccData(trait);

                    if (!traitGeneData || traitGeneData.length === 0) {
                        this.topGenesList = [];
                        return;
                    }

                    // Data is already for this specific trait, sort by PCC
                    let traitGenes = [...traitGeneData].sort((a, b) => (b.PCC || 0) - (a.PCC || 0));

                    // Mark top genes
                    traitGenes.forEach((g, i) => {
                        g.isTop = i < this.topCorrGenes;
                    });

                    // Load ALL genes, not just top slice
                    this.topGenesList = traitGenes;

                    // Invalidate gene table cache since data changed
                    this._geneFilterCache = null;
                    this._geneFilterKey = '';

                    // Select first top gene (matches what's shown in dropdown, has diagnostic plots)
                    const firstTopGene = this.topGenesList.find(g => g.isTop);
                    if (firstTopGene) {
                        this.selectedGene = firstTopGene.gene;
                    } else if (this.topGenesList.length > 0) {
                        // Fallback to first gene if no top genes marked
                        this.selectedGene = this.topGenesList[0].gene;
                    }
                },

                // Gene plot path (single-sample, takes plot type as parameter)
                getGenePlotPath(plotType) {
                    // Don't return a path during trait transitions to prevent bad requests
                    if (this.loadingGeneData || !this.selectedGene || !this.selectedTrait || !this.selectedSample) {
                        return '';
                    }
                    const safeSample = this.selectedSample.replace(/[^a-zA-Z0-9]/g, '_');
                    return `gene_diagnostic_plots/gene_${this.selectedTrait}_${this.selectedGene}_${safeSample}_${plotType}.png`;
                },

                // Sorting
                sortGenesBy(key) {
                    if (this.geneSortKey === key) this.geneSortAsc = !this.geneSortAsc;
                    else { this.geneSortKey = key; this.geneSortAsc = key === 'gene'; }
                },
                sortCauchyBy(key) {
                    if (this.cauchySortKey === key) this.cauchySortAsc = !this.cauchySortAsc;
                    else {
                        this.cauchySortKey = key;
                        this.cauchySortAsc = ['trait', 'annotation', 'sample_name'].includes(key);
                    }
                },

                // Manhattan Plot
                loadManhattanData() {
                    const trait = this.selectedTrait;
                    if (!trait) return;

                    this.isLoading = true;
                    const safeTrait = trait.replace(/[^a-zA-Z0-9]/g, "_");
                    const varName = `GSMAP_MANHATTAN_${safeTrait}`;

                    // Check if already loaded
                    if (this.manhattanLoadedTraits[trait] && window[varName]) {
                        this.manhattanData = window[varName];
                        this.renderManhattanPlot();
                        this.isLoading = false;
                        return;
                    }

                    // Load script dynamically
                    const script = document.createElement('script');
                    script.src = `js_data/manhattan_${trait}.js`;
                    script.onload = () => {
                        this.manhattanLoadedTraits[trait] = true;
                        if (window[varName]) {
                            this.manhattanData = window[varName];
                            this.renderManhattanPlot();
                        }
                        this.isLoading = false;
                    };
                    script.onerror = () => {
                        console.error(`Failed to load Manhattan data for ${trait}`);
                        this.isLoading = false;
                    };
                    document.body.appendChild(script);
                },

                renderManhattanPlot() {
                    const data = this.manhattanData;
                    if (!data || !data.x || data.x.length === 0) return;

                    const plotDiv = document.getElementById('manhattanPlot');
                    if (!plotDiv) return;

                    const trait = this.selectedTrait;
                    const highlightGene = this.selectedGene ? this.selectedGene.toUpperCase() : '';

                    // Build or reuse cached base traces (regular + top PCC SNPs)
                    if (!this.manhattanTraceCache) {
                        const regularX = [], regularY = [], regularColors = [];
                        const topX = [], topY = [], topGenes = [], topSnps = [];

                        // Single pass through data to separate regular and top SNPs
                        for (let i = 0; i < data.x.length; i++) {
                            if (data.is_top && data.is_top[i] === 1) {
                                topX.push(data.x[i]);
                                topY.push(data.y[i]);
                                topGenes.push(data.gene[i] || '');
                                topSnps.push(data.snp[i] || '');
                            } else {
                                regularX.push(data.x[i]);
                                regularY.push(data.y[i]);
                                regularColors.push(this.chrColors[data.chr[i] % 2]);
                            }
                        }

                        // Calculate maxX
                        let maxX = 0;
                        for (let i = 0; i < data.x.length; i++) {
                            if (data.x[i] > maxX) maxX = data.x[i];
                        }

                        this.manhattanTraceCache = {
                            regularX, regularY, regularColors,
                            topX, topY, topGenes, topSnps,
                            maxX
                        };
                    }

                    const cache = this.manhattanTraceCache;
                    const traces = [];

                    // Regular SNPs - hover disabled for performance
                    if (cache.regularX.length > 0) {
                        traces.push({
                            x: cache.regularX,
                            y: cache.regularY,
                            mode: 'markers',
                            type: 'scattergl',
                            hoverinfo: 'skip', // Disable hover for performance
                            marker: { size: 3, color: cache.regularColors, opacity: 0.6 },
                            name: 'SNPs'
                        });
                    }

                    // Top PCC genes (red) - keep hover
                    if (cache.topX.length > 0) {
                        traces.push({
                            x: cache.topX,
                            y: cache.topY,
                            mode: 'markers',
                            type: 'scattergl',
                            text: cache.topGenes.map((g, i) => `<b>${g}</b><br>SNP: ${cache.topSnps[i]}<br>-log10(p): ${cache.topY[i].toFixed(2)}`),
                            hoverinfo: 'text',
                            marker: { size: 6, color: '#e53e3e', opacity: 0.85 },
                            name: 'Top PCC Genes'
                        });
                    }

                    // Highlighted gene (green diamond) - always rebuild this trace
                    if (highlightGene) {
                        const highlightX = [], highlightY = [], highlightText = [];
                        for (let i = 0; i < data.x.length; i++) {
                            if ((data.gene[i] || '').toUpperCase() === highlightGene) {
                                highlightX.push(data.x[i]);
                                highlightY.push(data.y[i]);
                                highlightText.push(`<b>${data.gene[i]}</b><br>SNP: ${data.snp[i] || ''}<br>-log10(p): ${data.y[i].toFixed(2)}`);
                            }
                        }
                        if (highlightX.length > 0) {
                            traces.push({
                                x: highlightX,
                                y: highlightY,
                                mode: 'markers',
                                type: 'scattergl',
                                hoverinfo: 'text',
                                hovertext: highlightText,
                                marker: { size: 12, color: '#10b981', symbol: 'diamond', line: { width: 2, color: '#059669' } },
                                name: 'Selected Gene'
                            });
                        }
                    }

                    // Get chromosome tick positions
                    const chromTicks = this.chromTickPositions[trait] || {};
                    const tickvals = Object.values(chromTicks);
                    const ticktext = Object.keys(chromTicks);

                    const layout = {
                        title: { text: `Manhattan Plot: ${trait}`, font: { size: 16 } },
                        xaxis: {
                            title: 'Chromosome',
                            showgrid: false,
                            zeroline: false,
                            tickvals: tickvals,
                            ticktext: ticktext
                        },
                        yaxis: { title: '-log10(p)', showgrid: true, gridcolor: '#eee', zeroline: false },
                        hovermode: 'closest',
                        margin: { l: 60, r: 30, t: 50, b: 50 },
                        legend: { orientation: 'h', y: -0.15, itemsizing: 'constant' },
                        shapes: [{
                            type: 'line',
                            x0: 0,
                            x1: cache.maxX,
                            y0: -Math.log10(5e-8),
                            y1: -Math.log10(5e-8),
                            line: { color: '#e53e3e', width: 1, dash: 'dash' }
                        }]
                    };

                    const config = { responsive: true, displayModeBar: true };

                    // Use Plotly.react for efficient updates
                    if (this.manhattanPlotInitialized) {
                        Plotly.react(plotDiv, traces, layout, config);
                    } else {
                        Plotly.newPlot(plotDiv, traces, layout, config);
                        this.manhattanPlotInitialized = true;
                    }
                },

                // Cauchy Heatmap
                renderCauchyHeatmap() {
                    const plotDiv = document.getElementById('cauchyHeatmap');
                    if (!plotDiv || !this.cauchyData || this.cauchyData.length === 0) return;

                    let data = this.cauchyData.filter(r =>
                        (this.cauchyViewMode === 'all' ? r.type === 'aggregated' : r.type === 'sample') &&
                        r.annotation_name === this.selectedAnnotationCategory
                    );
                    if (data.length === 0) {
                        Plotly.purge(plotDiv);
                        return;
                    }

                    const metric = this.cauchyHeatmapMetric;
                    const annotationValues = [...new Set(data.map(r => r.annotation))].sort();
                    const traitValues = [...new Set(data.map(r => r.trait))].sort();

                    let zData = annotationValues.map(anno => traitValues.map(trait => {
                        const match = data.find(r => r.annotation === anno && r.trait === trait);
                        return match && match[metric] != null ? match[metric] : 0;
                    }));

                    // Deep copy for hover labels
                    let hoverZData = zData.map(row => [...row]);

                    // Normalize column-wise (trait-wise)
                    if (this.cauchyHeatmapNormalize) {
                        for (let j = 0; j < traitValues.length; j++) {
                            const colValues = zData.map(row => row[j]);
                            const minVal = Math.min(...colValues);
                            const maxVal = Math.max(...colValues);
                            const range = maxVal - minVal;
                            for (let i = 0; i < annotationValues.length; i++) {
                                if (range > 0) {
                                    zData[i][j] = (zData[i][j] - minVal) / range;
                                } else {
                                    zData[i][j] = 0;
                                }
                            }
                        }
                    }

                    let finalAnnotations = annotationValues;
                    let finalTraits = traitValues;

                    if (this.cauchyHeatmapCluster && traitValues.length > 1) {
                        try {
                            // Cluster rows (Annotations)
                            const rowOrder = this.clusterData(zData);
                            zData = rowOrder.map(i => zData[i]);
                            hoverZData = rowOrder.map(i => hoverZData[i]);
                            finalAnnotations = rowOrder.map(i => annotationValues[i]);

                            // Cluster columns (Traits)
                            const transposed = traitValues.map((_, j) => zData.map(row => row[j]));
                            const colOrder = this.clusterData(transposed);
                            zData = zData.map(row => colOrder.map(j => row[j]));
                            hoverZData = hoverZData.map(row => colOrder.map(j => row[j]));
                            finalTraits = colOrder.map(j => traitValues[j]);
                        } catch (e) {
                            console.error("Clustering failed, using default order:", e);
                        }
                    }

                    const metricLabel = {
                        'mlog10_p_cauchy': '-log10(p_cauchy)',
                        'mlog10_p_median': '-log10(p_median)',
                        'top_95_quantile': 'Q95 (-log10P)'
                    }[metric] || metric;

                    const colorscale = ['#313695', '#4575b4', '#74add1', '#fee090', '#fdae61', '#f46d43', '#d73027', '#a50026'];

                    Plotly.react(plotDiv, [{
                        z: zData,
                        x: finalTraits,
                        y: finalAnnotations,
                        type: 'heatmap',
                        colorscale: colorscale.map((c, i) => [i / (colorscale.length - 1), c]),
                        reversescale: false,
                        customdata: hoverZData,
                        hovertemplate: `Annotation: %{y}<br>Trait: %{x}<br>${metricLabel}: %{customdata:.2f}<extra></extra>`
                    }], {
                        title: { text: `Cauchy Enrichment Heatmap: ${metricLabel}`, font: { size: 16 } },
                        xaxis: { title: 'Trait', tickangle: 45, automargin: true },
                        yaxis: { title: 'Annotation', automargin: true },
                        margin: { l: 150, r: 50, t: 80, b: 150 }
                    }, { responsive: true });
                },

                // Simple Hierarchical Clustering (UPGMA / Average Linkage)
                clusterData(matrix) {
                    if (matrix.length <= 1) return [0];

                    const n = matrix.length;
                    const dist = (a, b) => Math.sqrt(a.reduce((acc, v, i) => acc + Math.pow(v - b[i], 2), 0));

                    // Initial clusters
                    let clusters = matrix.map((v, i) => ({
                        indices: [i],
                        vec: v,
                        size: 1
                    }));

                    // Distance matrix between clusters
                    const getClusterDist = (c1, c2) => dist(c1.vec, c2.vec);

                    while (clusters.length > 1) {
                        let minDist = Infinity;
                        let pair = [0, 1];

                        for (let i = 0; i < clusters.length; i++) {
                            for (let j = i + 1; j < clusters.length; j++) {
                                const d = getClusterDist(clusters[i], clusters[j]);
                                if (d < minDist) {
                                    minDist = d;
                                    pair = [i, j];
                                }
                            }
                        }

                        // Merge pair
                        const [i, j] = pair;
                        const c1 = clusters[i];
                        const c2 = clusters[j];

                        const mergedVec = c1.vec.map((v, idx) => (v * c1.size + c2.vec[idx] * c2.size) / (c1.size + c2.size));
                        const mergedCluster = {
                            indices: [...c1.indices, ...c2.indices],
                            vec: mergedVec,
                            size: c1.size + c2.size
                        };

                        // Update clusters array
                        clusters.splice(j, 1);
                        clusters.splice(i, 1, mergedCluster);
                    }

                    return clusters[0].indices;
                },

                // UMAP Plots
                renderUmapPlots() {
                    if (!this.umapData || !this.plotlyReady) return;

                    // Prepare trait color data
                    const trait = this.selectedTrait;
                    let traitColorValues = [];
                    const traitColorMap = ['#313695', '#4575b4', '#74add1', '#fee090', '#fdae61', '#f46d43', '#d73027', '#a50026'];
                    const traitColorLabel = `-log10(p) ${trait}`;

                    if (trait && this.umapData[trait]) {
                        traitColorValues = this.umapData[trait];
                    } else {
                        traitColorValues = new Array(this.umapData.spot.length).fill(0);
                    }

                    // Prepare annotation color data
                    const anno = this.selectedAnnotationCategory;
                    let annoColorValues = [];
                    let annoColorMap = null;

                    if (anno && this.umapData[anno]) {
                        annoColorValues = this.umapData[anno];
                        annoColorMap = (this.umapData.color_maps && this.umapData.color_maps[anno]) || null;
                    }

                    // Build hover text for trait view
                    const traitHoverText = this.umapData.spot.map((spot, i) => {
                        let text = `<b>Sample:</b> ${this.umapData.sample_name[i]}`;
                        if (trait && this.umapData[trait]) {
                            const traitVal = this.umapData[trait][i];
                            text += `<br><b>${trait}:</b> ${typeof traitVal === 'number' ? traitVal.toFixed(1) : traitVal}`;
                        }
                        return text;
                    });

                    // Build hover text for annotation view
                    const annoHoverText = this.umapData.spot.map((spot, i) => {
                        let text = `<b>Sample:</b> ${this.umapData.sample_name[i]}`;
                        if (anno && this.umapData[anno]) {
                            const val = this.umapData[anno][i];
                            text += `<br><b>${anno}:</b> ${typeof val === 'number' ? val.toFixed(1) : val}`;
                        }
                        return text;
                    });

                    const cellPointSize = this.umapData.point_size_cell || 4;
                    const nichePointSize = this.umapData.point_size_niche || 4;

                    // Render Cell Embedding - Trait
                    this.renderSingleUmap(
                        'umapCellPlotTrait',
                        this.umapData.umap_cell_x,
                        this.umapData.umap_cell_y,
                        traitColorValues,
                        traitColorMap,
                        true, // isContinuous
                        traitHoverText,
                        'Cell Embedding',
                        traitColorLabel,
                        cellPointSize
                    );

                    // Render Cell Embedding - Annotation
                    if (anno && annoColorValues.length > 0) {
                        this.renderSingleUmap(
                            'umapCellPlotAnnotation',
                            this.umapData.umap_cell_x,
                            this.umapData.umap_cell_y,
                            annoColorValues,
                            annoColorMap,
                            false, // isContinuous
                            annoHoverText,
                            'Cell Embedding',
                            anno,
                            cellPointSize
                        );
                    }

                    // Render Niche Embedding plots (if available)
                    if (this.umapHasNiche && this.umapData.umap_niche_x) {
                        // Render Niche Embedding - Trait
                        this.renderSingleUmap(
                            'umapNichePlotTrait',
                            this.umapData.umap_niche_x,
                            this.umapData.umap_niche_y,
                            traitColorValues,
                            traitColorMap,
                            true, // isContinuous
                            traitHoverText,
                            'Niche Embedding',
                            traitColorLabel,
                            nichePointSize
                        );

                        // Render Niche Embedding - Annotation
                        if (anno && annoColorValues.length > 0) {
                            this.renderSingleUmap(
                                'umapNichePlotAnnotation',
                                this.umapData.umap_niche_x,
                                this.umapData.umap_niche_y,
                                annoColorValues,
                                annoColorMap,
                                false, // isContinuous
                                annoHoverText,
                                'Niche Embedding',
                                anno,
                                nichePointSize
                            );
                        }
                    }
                },

                renderSingleUmap(divId, x, y, annoValues, colorMap, isContinuous, hoverText, title, annoName, pointSize) {
                    const plotDiv = document.getElementById(divId);
                    if (!plotDiv) return;

                    const opacity = this.umapData.default_opacity || 0.8;

                    let traces = [];
                    let layoutExtras = {};

                    if (isContinuous) {
                        // Single trace with colorbar for numeric data
                        traces.push({
                            x: x,
                            y: y,
                            mode: 'markers',
                            type: 'scattergl',
                            text: hoverText,
                            hovertemplate: '%{text}<extra></extra>',
                            marker: {
                                size: pointSize,
                                color: annoValues,
                                colorscale: colorMap.map((c, i) => [i / (colorMap.length - 1), c]),
                                opacity: opacity,
                                showscale: true,
                                colorbar: {
                                    title: annoName,
                                    thickness: 15,
                                    len: 0.5,
                                    y: 0.5
                                }
                            }
                        });
                        layoutExtras.showlegend = false;
                    } else {
                        // Discrete mapping - grouped by value for legend
                        const uniqueValues = [...new Set(annoValues)].sort();

                        // Default color scale if map not found
                        const defaultColors = this.getUmapColorScale(uniqueValues.length);

                        traces = uniqueValues.map((val, i) => {
                            const indices = annoValues.map((v, idx) => v === val ? idx : -1).filter(idx => idx >= 0);
                            return {
                                x: indices.map(idx => x[idx]),
                                y: indices.map(idx => y[idx]),
                                mode: 'markers',
                                type: 'scattergl',
                                name: val,
                                text: indices.map(idx => hoverText[idx]),
                                hovertemplate: '%{text}<extra></extra>',
                                marker: {
                                    size: pointSize,
                                    color: (colorMap && colorMap[val]) || defaultColors[i % defaultColors.length],
                                    opacity: opacity
                                }
                            };
                        });
                        layoutExtras.showlegend = uniqueValues.length <= 50;
                    }

                    const layout = {
                        title: { text: title, font: { size: 14 } },
                        xaxis: { title: 'UMAP 1', showgrid: false, zeroline: false },
                        yaxis: { title: 'UMAP 2', showgrid: false, zeroline: false },
                        hovermode: 'closest',
                        margin: { l: 50, r: 20, t: 40, b: 50 },
                        legend: {
                            orientation: 'v',
                            x: 1.02,
                            y: 1,
                            font: { size: 10 },
                            itemsizing: 'constant'
                        },
                        ...layoutExtras
                    };

                    const config = { responsive: true, displayModeBar: true };
                    Plotly.react(plotDiv, traces, layout, config);
                },

                // Spatial 2D Plot rendering (uses per-sample data loaded on-demand)
                // Render both 2D spatial plots (trait and annotation side by side)
                renderSpatial2DPlot() {
                    if (!this.plotlyReady || !this.currentSampleData) return;

                    // Render trait plot
                    this.renderSpatial2DPlotSingle('spatial2dPlotTrait', 'trait');
                    // Render annotation plot
                    this.renderSpatial2DPlotSingle('spatial2dPlotAnnotation', 'annotation');
                },

                // Helper to render a single 2D spatial plot
                renderSpatial2DPlotSingle(divId, plotType) {
                    const plotDiv = document.getElementById(divId);
                    if (!plotDiv) return;

                    const data = this.currentSampleData;
                    const sample = this.selectedSample;

                    // Data is already filtered per sample, no need to filter
                    const x = data.sx;
                    const y = data.sy;

                    if (!x || x.length === 0) {
                        console.warn(`No coordinates found for sample: ${sample}`);
                        return;
                    }

                    // Use pre-computed point size if available, otherwise calculate
                    const pointSize = data.point_size || this.estimateSpatialPointSize(x, y);

                    // Determine what to color by
                    let colorValues, colorLabel, isContinuous, colorMap;

                    if (plotType === 'trait') {
                        const trait = this.selectedTrait;
                        // Values already rounded to 1 decimal during export
                        colorValues = data[trait] || x.map(() => 0);
                        colorLabel = `-log10(p) ${trait}`;
                        isContinuous = true;
                        colorMap = ['#313695', '#4575b4', '#74add1', '#fee090', '#fdae61', '#f46d43', '#d73027', '#a50026'];
                    } else {
                        const anno = this.selectedAnnotationCategory;
                        colorValues = data[anno] || x.map(() => 'Unknown');
                        colorLabel = anno;
                        isContinuous = false;
                    }

                    // Build hover text with ALL annotations
                    const hoverText = data.spot.map((spot, i) => {
                        let text = `<b>Spot:</b> ${spot}`;
                        // Add all annotation columns
                        this.annotations.forEach(anno => {
                            if (data[anno]) {
                                const val = data[anno][i];
                                text += `<br><b>${anno}:</b> ${typeof val === 'number' ? val.toFixed(1) : val}`;
                            }
                        });
                        // Add trait value
                        if (this.selectedTrait && data[this.selectedTrait]) {
                            const val = data[this.selectedTrait][i];
                            const rounded = (val !== null && val !== undefined) ? val.toFixed(1) : 'N/A';
                            text += `<br><b>-log10(p):</b> ${rounded}`;
                        }
                        return text;
                    });

                    let traces = [];
                    let layoutExtras = {};

                    if (isContinuous) {
                        // Single trace with colorbar
                        traces.push({
                            x: x,
                            y: y,
                            mode: 'markers',
                            type: 'scattergl',
                            text: hoverText,
                            hoverinfo: 'text',
                            marker: {
                                size: pointSize,
                                color: colorValues,
                                colorscale: colorMap.map((c, i) => [i / (colorMap.length - 1), c]),
                                opacity: 0.8,
                                showscale: true,
                                colorbar: {
                                    title: '-log10(p)',
                                    thickness: 15,
                                    len: 0.5,
                                    y: 0.5
                                }
                            }
                        });
                        layoutExtras.showlegend = false;
                    } else {
                        // Discrete - group by category for legend
                        const uniqueValues = [...new Set(colorValues)].sort();

                        // Use UMAP color maps for consistency with UMAP and 3D plots
                        const anno = this.selectedAnnotationCategory;
                        const umapColorMap = this.umapData?.color_maps?.[anno];
                        const defaultColors = this.getUmapColorScale(uniqueValues.length);

                        traces = uniqueValues.map((val, i) => {
                            const indices = colorValues.map((v, idx) => v === val ? idx : -1).filter(idx => idx >= 0);
                            // Use UMAP color map if available, otherwise fall back to default
                            const color = (umapColorMap && umapColorMap[val]) || defaultColors[i % defaultColors.length];
                            return {
                                x: indices.map(idx => x[idx]),
                                y: indices.map(idx => y[idx]),
                                mode: 'markers',
                                type: 'scattergl',
                                name: val,
                                text: indices.map(idx => hoverText[idx]),
                                hoverinfo: 'text',
                                marker: {
                                    size: pointSize,
                                    color: color,
                                    opacity: 0.8
                                }
                            };
                        });
                        layoutExtras.showlegend = uniqueValues.length <= 50;
                    }

                    const titleText = plotType === 'trait' ? this.selectedTrait : this.selectedAnnotationCategory;
                    const layout = {
                        title: {
                            text: `${sample} - ${titleText}`,
                            font: { size: 14 }
                        },
                        xaxis: {
                            showgrid: false,
                            zeroline: false,
                            showticklabels: false,
                            scaleanchor: 'y'  // Maintain aspect ratio
                        },
                        yaxis: {
                            showgrid: false,
                            zeroline: false,
                            showticklabels: false,
                            autorange: (this.reportMeta.plot_origin === 'upper') ? 'reversed' : true
                        },
                        hovermode: 'closest',
                        margin: { l: 20, r: 20, t: 40, b: 20 },
                        legend: {
                            orientation: 'v',
                            x: 1.02,
                            y: 1,
                            font: { size: 10 },
                            itemsizing: 'constant'
                        },
                        ...layoutExtras
                    };

                    const config = { responsive: true, displayModeBar: true };

                    const initializedKey = plotType === 'trait' ? 'spatial2dPlotTraitInitialized' : 'spatial2dPlotAnnotationInitialized';
                    if (this[initializedKey]) {
                        Plotly.react(plotDiv, traces, layout, config);
                    } else {
                        Plotly.newPlot(plotDiv, traces, layout, config);
                        this[initializedKey] = true;
                    }
                },

                // Helper function to estimate point size for spatial plot
                estimateSpatialPointSize(x, y) {
                    if (x.length === 0) return 5;

                    // Calculate data range using reduce to avoid stack overflow on large arrays
                    // Note: Math.min(...arr) fails when arr.length > ~100k elements
                    let xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity;
                    for (let i = 0; i < x.length; i++) {
                        if (x[i] < xMin) xMin = x[i];
                        if (x[i] > xMax) xMax = x[i];
                        if (y[i] < yMin) yMin = y[i];
                        if (y[i] > yMax) yMax = y[i];
                    }

                    const xRange = xMax - xMin;
                    const yRange = yMax - yMin;
                    const dataRange = Math.max(xRange, yRange);

                    if (dataRange === 0) return 5;

                    // Estimate average point spacing using simple heuristic
                    // For a uniform distribution, avg spacing ~= sqrt(area / n_points)
                    const area = xRange * yRange;
                    const avgSpacing = Math.sqrt(area / x.length);

                    // Target: fill ~25-30% of area with points
                    // Point size in pixels, assuming ~600px viewport width
                    const viewportWidth = 600;
                    const pixelsPerDataUnit = viewportWidth / dataRange;
                    const pointSizePixels = avgSpacing * pixelsPerDataUnit * 0.8;

                    // Clamp between reasonable bounds
                    return Math.max(2, Math.min(15, pointSizePixels));
                },

                getUmapColorScale(n) {
                    // Categorical color palette
                    const palette = [
                        '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd',
                        '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf',
                        '#aec7e8', '#ffbb78', '#98df8a', '#ff9896', '#c5b0d5',
                        '#c49c94', '#f7b6d2', '#c7c7c7', '#dbdb8d', '#9edae5',
                        '#393b79', '#5254a3', '#6b6ecf', '#9c9ede', '#637939',
                        '#8ca252', '#b5cf6b', '#cedb9c', '#8c6d31', '#bd9e39'
                    ];
                    return palette.slice(0, Math.max(n, palette.length));
                }
            };
        }
    </script>

</body>

</html>